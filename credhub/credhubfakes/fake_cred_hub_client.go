// Code generated by counterfeiter. DO NOT EDIT.
package credhubfakes

import (
	"sync"

	credhubcredhub_cli "github.com/cloudfoundry-incubator/credhub-cli/credhub"
	"github.com/cloudfoundry-incubator/credhub-cli/credhub/credentials"
	"github.com/cloudfoundry-incubator/credhub-cli/credhub/credentials/values"
	"github.com/ishustava/migrator/credhub"
)

type FakeCredHubClient struct {
	SetPasswordStub        func(name string, value values.Password, overwrite credhubcredhub_cli.Mode) (credentials.Password, error)
	setPasswordMutex       sync.RWMutex
	setPasswordArgsForCall []struct {
		name      string
		value     values.Password
		overwrite credhubcredhub_cli.Mode
	}
	setPasswordReturns struct {
		result1 credentials.Password
		result2 error
	}
	setPasswordReturnsOnCall map[int]struct {
		result1 credentials.Password
		result2 error
	}
	SetCertificateStub        func(name string, value values.Certificate, overwrite credhubcredhub_cli.Mode) (credentials.Certificate, error)
	setCertificateMutex       sync.RWMutex
	setCertificateArgsForCall []struct {
		name      string
		value     values.Certificate
		overwrite credhubcredhub_cli.Mode
	}
	setCertificateReturns struct {
		result1 credentials.Certificate
		result2 error
	}
	setCertificateReturnsOnCall map[int]struct {
		result1 credentials.Certificate
		result2 error
	}
	SetRSAStub        func(name string, value values.RSA, overwrite credhubcredhub_cli.Mode) (credentials.RSA, error)
	setRSAMutex       sync.RWMutex
	setRSAArgsForCall []struct {
		name      string
		value     values.RSA
		overwrite credhubcredhub_cli.Mode
	}
	setRSAReturns struct {
		result1 credentials.RSA
		result2 error
	}
	setRSAReturnsOnCall map[int]struct {
		result1 credentials.RSA
		result2 error
	}
	SetSSHStub        func(name string, value values.SSH, overwrite credhubcredhub_cli.Mode) (credentials.SSH, error)
	setSSHMutex       sync.RWMutex
	setSSHArgsForCall []struct {
		name      string
		value     values.SSH
		overwrite credhubcredhub_cli.Mode
	}
	setSSHReturns struct {
		result1 credentials.SSH
		result2 error
	}
	setSSHReturnsOnCall map[int]struct {
		result1 credentials.SSH
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCredHubClient) SetPassword(name string, value values.Password, overwrite credhubcredhub_cli.Mode) (credentials.Password, error) {
	fake.setPasswordMutex.Lock()
	ret, specificReturn := fake.setPasswordReturnsOnCall[len(fake.setPasswordArgsForCall)]
	fake.setPasswordArgsForCall = append(fake.setPasswordArgsForCall, struct {
		name      string
		value     values.Password
		overwrite credhubcredhub_cli.Mode
	}{name, value, overwrite})
	fake.recordInvocation("SetPassword", []interface{}{name, value, overwrite})
	fake.setPasswordMutex.Unlock()
	if fake.SetPasswordStub != nil {
		return fake.SetPasswordStub(name, value, overwrite)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setPasswordReturns.result1, fake.setPasswordReturns.result2
}

func (fake *FakeCredHubClient) SetPasswordCallCount() int {
	fake.setPasswordMutex.RLock()
	defer fake.setPasswordMutex.RUnlock()
	return len(fake.setPasswordArgsForCall)
}

func (fake *FakeCredHubClient) SetPasswordArgsForCall(i int) (string, values.Password, credhubcredhub_cli.Mode) {
	fake.setPasswordMutex.RLock()
	defer fake.setPasswordMutex.RUnlock()
	return fake.setPasswordArgsForCall[i].name, fake.setPasswordArgsForCall[i].value, fake.setPasswordArgsForCall[i].overwrite
}

func (fake *FakeCredHubClient) SetPasswordReturns(result1 credentials.Password, result2 error) {
	fake.SetPasswordStub = nil
	fake.setPasswordReturns = struct {
		result1 credentials.Password
		result2 error
	}{result1, result2}
}

func (fake *FakeCredHubClient) SetPasswordReturnsOnCall(i int, result1 credentials.Password, result2 error) {
	fake.SetPasswordStub = nil
	if fake.setPasswordReturnsOnCall == nil {
		fake.setPasswordReturnsOnCall = make(map[int]struct {
			result1 credentials.Password
			result2 error
		})
	}
	fake.setPasswordReturnsOnCall[i] = struct {
		result1 credentials.Password
		result2 error
	}{result1, result2}
}

func (fake *FakeCredHubClient) SetCertificate(name string, value values.Certificate, overwrite credhubcredhub_cli.Mode) (credentials.Certificate, error) {
	fake.setCertificateMutex.Lock()
	ret, specificReturn := fake.setCertificateReturnsOnCall[len(fake.setCertificateArgsForCall)]
	fake.setCertificateArgsForCall = append(fake.setCertificateArgsForCall, struct {
		name      string
		value     values.Certificate
		overwrite credhubcredhub_cli.Mode
	}{name, value, overwrite})
	fake.recordInvocation("SetCertificate", []interface{}{name, value, overwrite})
	fake.setCertificateMutex.Unlock()
	if fake.SetCertificateStub != nil {
		return fake.SetCertificateStub(name, value, overwrite)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setCertificateReturns.result1, fake.setCertificateReturns.result2
}

func (fake *FakeCredHubClient) SetCertificateCallCount() int {
	fake.setCertificateMutex.RLock()
	defer fake.setCertificateMutex.RUnlock()
	return len(fake.setCertificateArgsForCall)
}

func (fake *FakeCredHubClient) SetCertificateArgsForCall(i int) (string, values.Certificate, credhubcredhub_cli.Mode) {
	fake.setCertificateMutex.RLock()
	defer fake.setCertificateMutex.RUnlock()
	return fake.setCertificateArgsForCall[i].name, fake.setCertificateArgsForCall[i].value, fake.setCertificateArgsForCall[i].overwrite
}

func (fake *FakeCredHubClient) SetCertificateReturns(result1 credentials.Certificate, result2 error) {
	fake.SetCertificateStub = nil
	fake.setCertificateReturns = struct {
		result1 credentials.Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeCredHubClient) SetCertificateReturnsOnCall(i int, result1 credentials.Certificate, result2 error) {
	fake.SetCertificateStub = nil
	if fake.setCertificateReturnsOnCall == nil {
		fake.setCertificateReturnsOnCall = make(map[int]struct {
			result1 credentials.Certificate
			result2 error
		})
	}
	fake.setCertificateReturnsOnCall[i] = struct {
		result1 credentials.Certificate
		result2 error
	}{result1, result2}
}

func (fake *FakeCredHubClient) SetRSA(name string, value values.RSA, overwrite credhubcredhub_cli.Mode) (credentials.RSA, error) {
	fake.setRSAMutex.Lock()
	ret, specificReturn := fake.setRSAReturnsOnCall[len(fake.setRSAArgsForCall)]
	fake.setRSAArgsForCall = append(fake.setRSAArgsForCall, struct {
		name      string
		value     values.RSA
		overwrite credhubcredhub_cli.Mode
	}{name, value, overwrite})
	fake.recordInvocation("SetRSA", []interface{}{name, value, overwrite})
	fake.setRSAMutex.Unlock()
	if fake.SetRSAStub != nil {
		return fake.SetRSAStub(name, value, overwrite)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setRSAReturns.result1, fake.setRSAReturns.result2
}

func (fake *FakeCredHubClient) SetRSACallCount() int {
	fake.setRSAMutex.RLock()
	defer fake.setRSAMutex.RUnlock()
	return len(fake.setRSAArgsForCall)
}

func (fake *FakeCredHubClient) SetRSAArgsForCall(i int) (string, values.RSA, credhubcredhub_cli.Mode) {
	fake.setRSAMutex.RLock()
	defer fake.setRSAMutex.RUnlock()
	return fake.setRSAArgsForCall[i].name, fake.setRSAArgsForCall[i].value, fake.setRSAArgsForCall[i].overwrite
}

func (fake *FakeCredHubClient) SetRSAReturns(result1 credentials.RSA, result2 error) {
	fake.SetRSAStub = nil
	fake.setRSAReturns = struct {
		result1 credentials.RSA
		result2 error
	}{result1, result2}
}

func (fake *FakeCredHubClient) SetRSAReturnsOnCall(i int, result1 credentials.RSA, result2 error) {
	fake.SetRSAStub = nil
	if fake.setRSAReturnsOnCall == nil {
		fake.setRSAReturnsOnCall = make(map[int]struct {
			result1 credentials.RSA
			result2 error
		})
	}
	fake.setRSAReturnsOnCall[i] = struct {
		result1 credentials.RSA
		result2 error
	}{result1, result2}
}

func (fake *FakeCredHubClient) SetSSH(name string, value values.SSH, overwrite credhubcredhub_cli.Mode) (credentials.SSH, error) {
	fake.setSSHMutex.Lock()
	ret, specificReturn := fake.setSSHReturnsOnCall[len(fake.setSSHArgsForCall)]
	fake.setSSHArgsForCall = append(fake.setSSHArgsForCall, struct {
		name      string
		value     values.SSH
		overwrite credhubcredhub_cli.Mode
	}{name, value, overwrite})
	fake.recordInvocation("SetSSH", []interface{}{name, value, overwrite})
	fake.setSSHMutex.Unlock()
	if fake.SetSSHStub != nil {
		return fake.SetSSHStub(name, value, overwrite)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.setSSHReturns.result1, fake.setSSHReturns.result2
}

func (fake *FakeCredHubClient) SetSSHCallCount() int {
	fake.setSSHMutex.RLock()
	defer fake.setSSHMutex.RUnlock()
	return len(fake.setSSHArgsForCall)
}

func (fake *FakeCredHubClient) SetSSHArgsForCall(i int) (string, values.SSH, credhubcredhub_cli.Mode) {
	fake.setSSHMutex.RLock()
	defer fake.setSSHMutex.RUnlock()
	return fake.setSSHArgsForCall[i].name, fake.setSSHArgsForCall[i].value, fake.setSSHArgsForCall[i].overwrite
}

func (fake *FakeCredHubClient) SetSSHReturns(result1 credentials.SSH, result2 error) {
	fake.SetSSHStub = nil
	fake.setSSHReturns = struct {
		result1 credentials.SSH
		result2 error
	}{result1, result2}
}

func (fake *FakeCredHubClient) SetSSHReturnsOnCall(i int, result1 credentials.SSH, result2 error) {
	fake.SetSSHStub = nil
	if fake.setSSHReturnsOnCall == nil {
		fake.setSSHReturnsOnCall = make(map[int]struct {
			result1 credentials.SSH
			result2 error
		})
	}
	fake.setSSHReturnsOnCall[i] = struct {
		result1 credentials.SSH
		result2 error
	}{result1, result2}
}

func (fake *FakeCredHubClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.setPasswordMutex.RLock()
	defer fake.setPasswordMutex.RUnlock()
	fake.setCertificateMutex.RLock()
	defer fake.setCertificateMutex.RUnlock()
	fake.setRSAMutex.RLock()
	defer fake.setRSAMutex.RUnlock()
	fake.setSSHMutex.RLock()
	defer fake.setSSHMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCredHubClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ credhub.CredHubClient = new(FakeCredHubClient)
